//
//  MapViewController.swift
//  contrast
//
//  Created by Roman Kiruxin on 15.07.2023.
//  Copyright (c) 2023 ___ORGANIZATIONNAME___. All rights reserved.
//
//  This file was generated by the Clean Swift Xcode Templates so
//  you can apply clean architecture to your iOS and Mac projects,
//  see http://clean-swift.com
//

import UIKit
import YandexMapsMobile
import CoreLocation

protocol MapDisplayLogic: AnyObject {
    func display(viewModel: Map.Model.ViewModel.ViewModelType)
}

final class MapViewController: UIViewController {
    
    // MARK: - IBOutlets
    private let mapView: YMKMapView = {
        let view = YMKMapView()
        return view
    }()
    
    private let mapCursor: UIImageView = {
        let imageView = UIImageView()
        imageView.image = R.image.mapCursor()
        return imageView
    }()
    
    private let containerView: UIView = {
        let view = UIView()
        view.backgroundColor = .mainBackgroundColor
        return view
    }()
    
    private let dragView: UIView = {
        let view = UIView()
        view.backgroundColor = .textLight
        view.layer.cornerRadius = 2.5
        return view
    }()
    
    private let addressLabel: UILabel = {
        let label = UILabel()
        label.font = GeneralFonts.generalRegular17
        label.textColor = .textDark
        label.textAlignment = .center
        label.text = "Address"
        label.numberOfLines = 2
        return label
    }()
    
    private let mainButton: MainButton = {
        let button = MainButton()
        button.setTitle(R.string.localizable.specifyAddress(), for: .normal)
        return button
    }()
    
    private let addressesCollectionView: UICollectionView = {
        let flowLayout = UICollectionViewFlowLayout.init()
        flowLayout.scrollDirection = .horizontal
        
        flowLayout.sectionHeadersPinToVisibleBounds = true
        let cv = UICollectionView(frame: CGRect.zero, collectionViewLayout: flowLayout)
        cv.showsHorizontalScrollIndicator = false
        cv.backgroundColor = .clear
        return cv
    }()
    
    private let backButton: MainButton = {
        let button = MainButton()
        button.setupStyle(style: .border(image: R.image.leftArrow()))
        button.layer.cornerRadius = 22
        return button
    }()
    
    private let searchAddressButton: MainButton = {
        let button = MainButton()
        button.setupStyle(style: .border(image: R.image.searchIcon()))
        button.layer.cornerRadius = 22
        return button
    }()
    
    private let userLocationButton: MainButton = {
        let button = MainButton()
        button.setupStyle(style: .border(image: R.image.userLocation()))
        button.layer.cornerRadius = 22
        return button
    }()
    
    // MARK: - External vars
    var interactor: MapBusinessLogic?
    var router: (NSObjectProtocol & MapRoutingLogic & MapDataPassing)?
    
    // MARK: - Internal vars
    private let locationManager = CLLocationManager()
    
    private var selectedAddress: AddressDataModel?
    private var userAddresses: [UserAddressModel] = []
    private var currentAddress = 0
    private var activeZones: [ZonesGeolocateInfo] = []
    private var selectedUserAddress: UserAddressModel? {
        didSet {
            if selectedUserAddress == nil {
                mainButton.setTitle(R.string.localizable.specifyAddress(), for: .normal)
            } else {
                mainButton.setTitle(R.string.localizable.confirmAddress(), for: .normal)
            }
        }
    }
    private var activeLat: Double?
    private var activeLon: Double?
    
    private var map: YMKMap {
        return mapView.mapWindow.map
    }
    
    // MARK: - Object lifecycle
    override init(nibName nibNameOrNil: String?, bundle nibBundleOrNil: Bundle?) {
        super.init(nibName: nibNameOrNil, bundle: nibBundleOrNil)
        MapConfigurator.shared.configure(self)
    }
    
    required init?(coder aDecoder: NSCoder) {
        super.init(coder: aDecoder)
        MapConfigurator.shared.configure(self)
    }
    
    // MARK: - View lifecycle
    override func viewDidLoad() {
        super.viewDidLoad()
        setupView()
    }
    
    override func viewWillAppear(_ animated: Bool) {
        super.viewWillAppear(animated)
        
        if let activeSearchAddress = UserDefaultsWorker.fetchActiveSearchAddress() {
            let latitude = activeSearchAddress.latitude
            let longitude = activeSearchAddress.longitude
            
            mapView.mapWindow.map.move(
                       with: YMKCameraPosition(target: YMKPoint(latitude: latitude, longitude: longitude), zoom: 18, azimuth: 0, tilt: 0),
                       animationType: YMKAnimation(type: YMKAnimationType.smooth, duration: 3),
                       cameraCallback: nil)
            interactor?.make(request: .zonesCheck(latitude, longitude))
            UserDefaultsWorker.removeActiveSearchAddress()
        }
    }
}

// MARK: - Display logic
extension MapViewController: MapDisplayLogic {
    
    func display(viewModel: Map.Model.ViewModel.ViewModelType) {
        switch viewModel {
        case .presentZonesCheck(let viewModel, let lat, let lon):
            if viewModel.isInZone {
                addressLabel.text = viewModel.address?.address
                mainButton.isEnabledButton = true
                
                selectedAddress = viewModel.address
                
                interactor?.make(request: .zonesGeolocate(lat!, lon!))
            } else {
                addressLabel.text = R.string.localizable.addressOutsideServiceArea()
                mainButton.isEnabledButton = false
            }
        case .presentAllZones(let viewModel):
            setupPoligons(viewModel: viewModel)
        case .presentUserAddresses(let viewModel):
//            userAddresses = [UserAddressModel(id: 0,
//                                              city: "",
//                                              street: "Ул. Рощева",
//                                              house: "д.3 п5",
//                                              latitude: 55.737773999615364,
//                                              longitude: 38,
//                                              type: 1,
//                                              comment: "",
//                                              intercom: "",
//                                              entrance: "",
//                                              floor: "",
//                                              flat: "",
//                                              isActive: false),
//                             UserAddressModel(id: 0,
//                                               city: "",
//                                               street: "Ул. Третьяковская",
//                                               house: "д.3 п5",
//                                               latitude: 55.79467,
//                                               longitude: 37.623116,
//                                               type: 2,
//                                               comment: "",
//                                               intercom: "",
//                                               entrance: "",
//                                               floor: "",
//                                               flat: "",
//                                               isActive: false),
//                             UserAddressModel(id: 0,
//                                               city: "",
//                                               street: "Ул. Рощева",
//                                               house: "д.3 п5",
//                                               latitude: 55.74677,
//                                               longitude: 37.490281,
//                                               type: 2,
//                                               comment: "",
//                                               intercom: "",
//                                               entrance: "",
//                                               floor: "",
//                                               flat: "",
//                                               isActive: false)]
//            userAddresses = []
            userAddresses = viewModel
            if !userAddresses.isEmpty {
                addressesCollectionView.snp.updateConstraints {
                    $0.height.equalTo(56)
                }
            } else {
                addressesCollectionView.snp.updateConstraints {
                    $0.height.equalTo(0)
                }
            }
            addressesCollectionView.reloadData()
        case .presentGeolocate(let viewModel):
            activeZones = viewModel
        }
    }
}

//MARK: - UICollectionViewDelegate, UICollectionViewDataSource, UICollectionViewDelegateFlowLayout
extension MapViewController: UICollectionViewDelegate, UICollectionViewDataSource, UICollectionViewDelegateFlowLayout {
    func collectionView(_ collectionView: UICollectionView, numberOfItemsInSection section: Int) -> Int {
        return userAddresses.count
    }

    func collectionView(_ collectionView: UICollectionView, cellForItemAt indexPath: IndexPath) -> UICollectionViewCell {
        let cell = collectionView.dequeueReusableCell(withType: AddressCollectionViewCell.self, for: indexPath)
        cell.setupCell(model: userAddresses[indexPath.item])
        return cell
    }
    
    func collectionView(_ collectionView: UICollectionView, didSelectItemAt indexPath: IndexPath) {
        collectionView.selectItem(at: IndexPath(row: indexPath.item, section: 0), animated: true, scrollPosition: .left)
        currentAddress = indexPath.item
        selectedUserAddress = userAddresses[currentAddress]
        
        activeLat = selectedUserAddress?.latitude
        activeLon = selectedUserAddress?.longitude
        
        for i in 0..<userAddresses.count {
            if i == currentAddress {
                userAddresses[i].isActive = true
            } else {
                userAddresses[i].isActive = false
            }
        }
        
        addressesCollectionView.reloadData()
        
        mapView.mapWindow.map.move(
            with: YMKCameraPosition(target: YMKPoint(latitude: userAddresses[currentAddress].latitude, longitude: userAddresses[currentAddress].longitude), zoom: 18, azimuth: 0, tilt: 0),
                   animationType: YMKAnimation(type: YMKAnimationType.smooth, duration: 3),
                   cameraCallback: nil)
    }

    func collectionView(_ collectionView: UICollectionView, layout collectionViewLayout: UICollectionViewLayout, sizeForItemAt indexPath: IndexPath) -> CGSize {
        
        if userAddresses[indexPath.item].isActive {
            let widthStreet = userAddresses[indexPath.item].street.size(withAttributes: [
                NSAttributedString.Key.font : GeneralFonts.generalRegular13
            ])
            
            let widthHouse = userAddresses[indexPath.item].house.size(withAttributes: [
                NSAttributedString.Key.font : GeneralFonts.generalRegular13
            ])
            
            return CGSize(width: widthStreet.width + widthHouse.width + 72, height: 46)
        } else {
            let widthStreet = userAddresses[indexPath.item].street.size(withAttributes: [
                NSAttributedString.Key.font : GeneralFonts.generalRegular13
            ])
            
            let widthHouse = userAddresses[indexPath.item].house.size(withAttributes: [
                NSAttributedString.Key.font : GeneralFonts.generalRegular13
            ])
            
            return CGSize(width: widthStreet.width + widthHouse.width + 50, height: 46)
        }
    }

    func collectionView(_ collectionView: UICollectionView, layout collectionViewLayout: UICollectionViewLayout, insetForSectionAt section: Int) -> UIEdgeInsets {
        return UIEdgeInsets(top: 10, left: 12, bottom: 10, right: 12)
    }

    func collectionView(_ collectionView: UICollectionView, layout collectionViewLayout: UICollectionViewLayout, minimumLineSpacingForSectionAt section: Int) -> CGFloat {
        return CGFloat(10)
    }

    func collectionView(_ collectionView: UICollectionView, layout collectionViewLayout: UICollectionViewLayout, minimumInteritemSpacingForSectionAt section: Int) -> CGFloat {
        return CGFloat(10)
    }
}


// MARK: - Private methods
private extension MapViewController {
    private func setupView() {
        view.backgroundColor = .mainBackgroundColor
        
        view.addSubview(mapView)
        view.addSubview(mapCursor)
        
        view.addSubview(containerView)
        containerView.addSubview(dragView)
        containerView.addSubview(addressLabel)
        containerView.addSubview(mainButton)
        
        view.addSubview(addressesCollectionView)
        view.addSubview(backButton)
        view.addSubview(searchAddressButton)
        view.addSubview(userLocationButton)
        
        addressesCollectionView.delegate = self
        addressesCollectionView.dataSource = self
        
        let swipeUp = UISwipeGestureRecognizer(target: self, action: #selector(swipe))
        swipeUp.direction = .up
        containerView.addGestureRecognizer(swipeUp)
        
        mapView.mapWindow.map.isRotateGesturesEnabled = false
        map.addCameraListener(with: self)
        
        backButton.addTarget(self, action: #selector(pressBackButton), for: .touchUpInside)
        searchAddressButton.addTarget(self, action: #selector(pressSearchAddressButton), for: .touchUpInside)
        userLocationButton.addTarget(self, action: #selector(pressUserLocationButton), for: .touchUpInside)
        
        mainButton.addTarget(self, action: #selector(pressMainButton), for: .touchUpInside)
        
        let gesture = UITapGestureRecognizer(target: self, action: #selector(tapOnMap))
        mapView.addGestureRecognizer(gesture)
        
        registerCollectionViewCells()
        setLocationManager()
        setupConstraints()
        
        interactor?.make(request: .zonesAll)
        interactor?.make(request: .fetchUserAddresses)
    }
    
    private func registerCollectionViewCells() {
        addressesCollectionView.register(cellTypes: [AddressCollectionViewCell.self])
    }
    
    private func setupPoligons(viewModel: [ZonesAllModel]) {
        for item in viewModel {
            let polygon = YMKPolygon(outerRing: YMKLinearRing(points: item.coordinates), innerRings: [])
            let polygonMapObject = map.mapObjects.addPolygon(with: polygon)
            polygonMapObject.fillColor = UIColor.mainButtonColor.withAlphaComponent(0.16)
            polygonMapObject.strokeWidth = 3.0
            polygonMapObject.strokeColor = .mainButtonColor
        }
    }
    
    private func setupConstraints() {
        mapView.snp.makeConstraints {
            $0.edges.equalToSuperview()
        }
        //TODO: поправить курсор по высоте Y
        mapCursor.snp.makeConstraints {
            $0.centerX.equalToSuperview()
            $0.centerY.equalToSuperview().offset(-15)
            $0.width.equalTo(32)
            $0.height.equalTo(52)
        }
        
        containerView.snp.makeConstraints {
            $0.bottom.equalToSuperview()
            $0.leading.trailing.equalToSuperview()
            $0.height.equalTo(200)
        }
        
        dragView.snp.makeConstraints {
            $0.top.equalToSuperview().inset(8)
            $0.centerX.equalToSuperview()
            $0.width.equalTo(60)
            $0.height.equalTo(5)
        }
        
        addressLabel.snp.makeConstraints {
            $0.top.equalToSuperview().inset(34)
            $0.centerX.equalToSuperview()
            $0.leading.trailing.equalToSuperview().inset(16)
        }
        
        mainButton.snp.makeConstraints {
            $0.bottom.equalTo(view.safeAreaLayoutGuide).inset(20)
            $0.leading.trailing.equalToSuperview().inset(16)
            $0.height.equalTo(46)
        }
        
        addressesCollectionView.snp.makeConstraints {
            $0.bottom.equalTo(containerView.snp.top).offset(-12)
            $0.leading.trailing.equalToSuperview()
            $0.height.equalTo(56)
        }
        
        backButton.snp.makeConstraints {
            $0.bottom.equalTo(addressesCollectionView.snp.top).offset(-16)
            $0.leading.equalToSuperview().inset(16)
            $0.width.height.equalTo(44)
        }
        
        userLocationButton.snp.makeConstraints {
            $0.bottom.equalTo(backButton)
            $0.trailing.equalToSuperview().inset(16)
            $0.width.height.equalTo(44)
        }
        
        searchAddressButton.snp.makeConstraints {
            $0.bottom.equalTo(userLocationButton.snp.top).offset(-16)
            $0.trailing.equalTo(userLocationButton)
            $0.width.height.equalTo(44)
        }
    }
    
    private func checkMinSum() -> Bool {
        var isMinSumOrder = false
        let busketSum = LocalBasket.shared.calcBasket()
        var minSumOrderInZone: Float = 0.0
        
        for zone in activeZones {
            if zone.minOrderSum <= busketSum {
                isMinSumOrder = true
            } else {
                if zone.minOrderSum > minSumOrderInZone {
                    minSumOrderInZone = zone.minOrderSum
                }
            }
        }
        
        if !isMinSumOrder {
            showAlertError(title: "\(R.string.localizable.alertMinAmount())\(minSumOrderInZone) ₽")
            return false
        }
        return true
    }
    
    private func parseAddress() -> UserAddressRequest {
        let addressData = UserAddressRequest(city: selectedUserAddress!.city,
                                             street: selectedUserAddress!.street,
                                             house: selectedUserAddress!.house,
                                             latitude: selectedUserAddress!.latitude,
                                             longitude: selectedUserAddress!.longitude,
                                             type: selectedUserAddress!.type,
                                             comment: selectedUserAddress!.comment,
                                             intercom: selectedUserAddress!.intercom,
                                             entrance: selectedUserAddress!.entrance,
                                             floor: selectedUserAddress!.floor,
                                             flat: selectedUserAddress!.flat)
        return addressData
    }
    
    @objc private func tapOnMap() {
        selectedUserAddress = nil
        
        for i in 0..<userAddresses.count {
            userAddresses[i].isActive = false
        }
        addressesCollectionView.reloadData()
    }
    
    @objc private func swipe() {
        if !checkMinSum() {
            return
        }
        
        if activeZones.count == 1, activeZones.first!.isExpress {
            let isAvailableOrder = LocalBasket.shared.getItemsWithWithoutExpress()
            
            if !isAvailableOrder {
                if let selectedAddress = selectedAddress {
                    router?.routeToAddressClarification(selectedAddress: selectedAddress, activeZones: activeZones)
                }
            } else {
                showAlertError(title: R.string.localizable.alertBulkyGoods())
            }
        } else {
            if let selectedAddress = selectedAddress {
                router?.routeToAddressClarification(selectedAddress: selectedAddress, activeZones: activeZones)
            }
        }
    }
    
    @objc private func pressSearchAddressButton() {
        UserDefaultsWorker.removeActiveSearchAddress()
        router?.routeToSearchAddress()
    }
    
    @objc private func pressUserLocationButton() {
        checkLocationAuthorization()
    }
    
    @objc private func pressBackButton() {
        dismiss(animated: true)
    }
    
    @objc private func pressMainButton() {
        if !checkMinSum() {
            return
        }
        
        if activeZones.count == 1, activeZones.first!.isExpress {
            let isAvailableOrder = LocalBasket.shared.getItemsWithWithoutExpress()
            
            if !isAvailableOrder {
                if let selectedUserAddress = selectedUserAddress {
                    router?.routeToTimeIntervalOrdering(activeZones: activeZones, addressData: parseAddress())
                } else {
                    router?.routeToAddressClarification(selectedAddress: selectedAddress!, activeZones: activeZones)
                }
            } else {
                showAlertError(title: R.string.localizable.alertBulkyGoods())
            }
        } else {
            if let selectedUserAddress = selectedUserAddress {
                router?.routeToTimeIntervalOrdering(activeZones: activeZones, addressData: parseAddress())
            } else {
                if let selectedAddress = selectedAddress {
                    router?.routeToAddressClarification(selectedAddress: selectedAddress, activeZones: activeZones)
                }
            }
        }
    }
}

// MARK: - YMKMapCameraListener
extension MapViewController: YMKMapCameraListener {
    func onCameraPositionChanged(with map: YMKMap, cameraPosition: YMKCameraPosition, cameraUpdateReason: YMKCameraUpdateReason, finished: Bool) {
        
        let latitude = cameraPosition.target.latitude
        let longitude = cameraPosition.target.longitude
        
        interactor?.make(request: .zonesCheck(latitude, longitude))
    }
}

//MARK: - LocationManager Delegates
extension MapViewController: CLLocationManagerDelegate {
    
    private func setLocationManager() {
        checkLocationAuthorization()
        
        DispatchQueue.global().async {
            if CLLocationManager.locationServicesEnabled() {
                self.locationManager.delegate = self
                self.locationManager.desiredAccuracy = kCLLocationAccuracyBestForNavigation
                self.locationManager.startUpdatingLocation()
            }
        }
    }
    
    private func checkLocationAuthorization() {
        switch locationManager.authorizationStatus {
        case .notDetermined:
            locationManager.requestWhenInUseAuthorization()
        case .denied:
            mapView.mapWindow.map.move(
                with: YMKCameraPosition(target: YMKPoint(latitude: Constants.defaultLatitude, longitude: Constants.defaultLongitude), zoom: 18, azimuth: 0, tilt: 0),
                       animationType: YMKAnimation(type: YMKAnimationType.smooth, duration: 3),
                       cameraCallback: nil)
            interactor?.make(request: .zonesCheck(Constants.defaultLatitude, Constants.defaultLongitude))
        default:
            let latitude = locationManager.location?.coordinate.latitude
            let longitude = locationManager.location?.coordinate.longitude
            
            mapView.mapWindow.map.move(
                       with: YMKCameraPosition(target: YMKPoint(latitude: latitude ?? 0, longitude: longitude ?? 0), zoom: 18, azimuth: 0, tilt: 0),
                       animationType: YMKAnimation(type: YMKAnimationType.smooth, duration: 3),
                       cameraCallback: nil)
            interactor?.make(request: .zonesCheck(latitude ?? 0, longitude ?? 0))
        }
    }
     
    func locationManagerDidChangeAuthorization(_ manager: CLLocationManager) {
        checkLocationAuthorization()
    }
}
